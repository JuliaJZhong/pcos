# -*- coding: utf-8 -*-
"""clustering_and_annotation_integrated

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aizqv8l2FL8JhHeywV1FwnmN9Vx_j1UA
"""

!pip install scanpy
!pip install igraph
#!pip install decoupler

import anndata as ad
import matplotlib.pyplot as plt
import numpy as np
import os
import pandas as pd
import seaborn as sns
import scanpy as sc
#import decoupler as dc

from google.colab import drive
drive.mount('/content/drive')

data_path = '/content/drive/MyDrive/20.440 Project/data'

"""## load post-integration (batch-corrected) data and visualize UMAP"""

integrated = sc.read_h5ad(data_path + '/integrated_2025-04-09.h5ad')
integrated

#raw = sc.read_h5ad(data_path + '/adata_2025-04-10.h5ad')
#raw

print(integrated.shape)
integrated_small = integrated[:,:500]
integrated_small
print(integrated_small.obs.shape)
integrated_small.X

# For example, generate 200 distinct colors
my_palette = sns.color_palette("tab20", 20) * 10  # Repeat tab20 10 times to get 200
my_palette = my_palette[:20]  # Trim to exactly the number of categories you need

sc.pl.umap(
    integrated,
    color="sample",
    palette=my_palette,
    # setting a smaller point size to get prevent overlap
    size=10,
)

# Create a new column in 'obs' to categorize samples into two groups
PCOS = ['Mc03-F', 'Mc10-F', 'Mc16-F', 'Mc26-F', 'Mc27-F', 'Mc03-C', 'Mc10-C', 'Mc16-C', 'Mc26-C', 'Mc27-C'] #sample names
healthy = ['Mc02-F', 'Mc06-F', 'Mc31-F', 'Mc40-F', 'Mc50-F', 'Mc02-C', 'Mc06-C', 'Mc31-C', 'Mc40-C', 'Mc50-C'] #sample names

integrated.obs['disease_status'] = integrated.obs['sample'].apply(
    lambda x: 'PCOS' if x in PCOS else ('HC' if x in healthy else 'other')
)
sc.pl.umap(
    integrated,
    color="disease_status",  # Color by the new 'group' column
    palette=["pink", "green"],  # Specify the colors for the two groups
    size=2,  # Smaller point size to avoid overlap
)

#umap based on healthy vs diseased

"""## Leiden graph-clustering"""

# using the igraph implementation and a fixed number of iterations can be
# significantly faster, especially for larger datasets
# TODO: mess around with leiden parameters for cell type resolution
sc.pp.neighbors(integrated)
sc.tl.leiden(integrated, flavor="igraph", n_iterations=2)

# plot UMAP colored by leiden clusters (ideally these are cell types!)
sc.pl.umap(integrated, color=["leiden"], legend_loc="on data")

print((integrated.obs['sample'][0]))

# Figure out which clusters came from controls and which came from PCOS patients
PCOS = ['Mc03-F', 'Mc10-F', 'Mc16-F', 'Mc26-F', 'Mc27-F', 'Mc03-C', 'Mc10-C', 'Mc16-C', 'Mc26-C', 'Mc27-C'] #sample names
healthy = ['Mc02-F', 'Mc06-F', 'Mc31-F', 'Mc40-F', 'Mc50-F', 'Mc02-C', 'Mc06-C', 'Mc31-C', 'Mc40-C', 'Mc50-C'] #sample names

#for integrated, uncomment the line below
cluster_assignments = {0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [], 11: [], 12: [], 13: []}

#for raw, uncomment line below
#cluster_assignments = {0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [], 11: [], 12: [], 13: [], 14: [], 15: [], 16: [], 17: [], 18: [], 19: []}
for index in range(len(integrated.obs['leiden'])):
  cluster = int(integrated.obs['leiden'][index]) #typecast to int to match key type in cluster_assignments dictionary
  sample_name = integrated.obs['sample'][index]
  if (sample_name in PCOS):
    cluster_assignments[cluster].append('PCOS')
  elif (sample_name in healthy):
    cluster_assignments[cluster].append('healthy')
  else:
    print("oops!")


cluster_names = {}
for key, value in cluster_assignments.items():
  count_PCOS = value.count('PCOS')
  if (count_PCOS > (len(value)/2)):
    cluster_names[key] = ['PCOS', (count_PCOS/len(value)*100)]
  else:
    cluster_names[key] = ['healthy', ((1-(count_PCOS)/len(value))*100)]

print(cluster_names)

PCOS_proportion = {}
for key, value in cluster_assignments.items():
  count_PCOS = value.count('PCOS')
  PCOS_proportion[key] = (count_PCOS/len(value))

print(PCOS_proportion)


# Extract keys and values
clusters = list(PCOS_proportion.keys())
diseased = list(PCOS_proportion.values())
print(diseased)
healthy = [1 - d for d in diseased]


# Plot
plt.figure(figsize=(8, 5))
plt.barh(clusters, diseased, label='Diseased', color='tomato')
plt.barh(clusters, healthy, left=diseased, label='Healthy', color='lightgreen')

# Labels and styling
plt.ylabel('Leiden Cluster')
plt.xlabel('Proportion of Cells')
plt.title('Proportion of Diseased vs. Healthy Cells per Cluster')
plt.yticks(clusters)
plt.xlim(0, 1)
plt.legend()
plt.tight_layout()
plt.show()

"""Leiden Clusters:
- 0-7: healthy
- 8-15: PCOS
- {0: ['healthy', 69.21817437576749],
- 1: ['healthy', 50.20729684908789],
- 2: ['PCOS', 68.19787985865725],
- 3: ['healthy', 60.598179453836146],
- 4: ['PCOS', 66.2467580585402],
- 5: ['healthy', 88.75651526433359],
- 6: ['healthy', 63.06715063520871],
- 7: ['healthy', 72.87169042769858],
- 8: ['PCOS', 80.13937282229965],
- 9: ['PCOS', 72.52747252747253],
- 10: ['PCOS', 69.21348314606742],
- 11: ['healthy', 54.2654028436019],
- 12: ['PCOS', 54.65116279069767],
- 13: ['PCOS', 100.0]}

##Cell type annotations
Used this tutorial: https://decoupler-py.readthedocs.io/en/latest/notebooks/cell_annotation.html

alternative option: https://www.sc-best-practices.org/cellular_structure/
annotation.html

differential expressed clusters
do top 10 DE genes in that clusters
copy paste and put in enricher website

DEG analysis for each cluster -> csv of DEGs

copy/paste top 25 into enricher

###DGE Analysis
"""

# Perform differential expression between clusters
df = sc.tl.rank_genes_groups(integrated, groupby='leiden', method='wilcoxon')

df = sc.get.rank_genes_groups_df(integrated, group='0')
print(df.shape)  # Should be (100, x) if 100 genes returned
print(df.head())

df_filtered = df[(df['pvals_adj'] < 0.05) & (df['logfoldchanges'].abs() > 0.25)]
print(df_filtered.shape)

df.sort_values('logfoldchanges', ascending=False).head(10)

'''
#bonus 3 line code that may do the same exact thing as the block below (according to ChatGPT. i dont fully trust it tho lol)
all_df = sc.get.rank_genes_groups_df(raw, group=None)  # All groups at once
filtered_df = all_df[(all_df['pvals_adj'] < 0.05) & (abs(all_df['logfoldchanges']) > 0.25)]
filtered_df.to_csv('/content/drive/MyDrive/20.440 Project/deg_filtered.csv', index=False)
'''

# Get the cluster names
cluster_names = integrated.uns['rank_genes_groups']['names'].dtype.names

# Create an empty list for results
all_deg_results = []

# Loop over each cluster name
for cluster_name in cluster_names:
    # Get data for this cluster
    gene_names = integrated.uns['rank_genes_groups']['names'][cluster_name]
    logfoldchanges = integrated.uns['rank_genes_groups']['logfoldchanges'][cluster_name]
    pvals = integrated.uns['rank_genes_groups']['pvals'][cluster_name]
    pvals_adj = integrated.uns['rank_genes_groups']['pvals_adj'][cluster_name]

    # Filter: keep only DEGs that pass significance thresholds (optional)
    for gene, logfc, pval, padj in zip(gene_names, logfoldchanges, pvals, pvals_adj):
        if padj < 0.01 and abs(logfc) > 1:  # â† You can adjust these thresholds
            all_deg_results.append({
                'gene': gene,
                'logfoldchanges': logfc,
                'pvals': pval,
                'pvals_adj': padj,
                'cluster': cluster_name
            })

# Convert to DataFrame
final_deg_results = pd.DataFrame(all_deg_results)

# Sort if desired
final_deg_results_sorted = final_deg_results.sort_values(by=['cluster', 'logfoldchanges'], ascending=[True, False])

# Optionally, save the results to a CSV file
final_deg_results_sorted.to_csv('/content/drive/MyDrive/20.440 Project/deg_integrated.csv', index=False)

# Show the first few rows of the sorted DataFrame
print(final_deg_results_sorted.head())

'''
This code is somewhat wrong and returns only ~20 DEGs per cluster
# Get the unique Leiden clusters
leiden_clusters = raw.obs['leiden'].unique()

# Create an empty list to hold all results
all_deg_results = []


# Loop over clusters (groups) in rank_genes_groups
for cluster_idx in range(len(raw.uns['rank_genes_groups']['names'])):
    # Get the gene names for this cluster
    gene_names = raw.uns['rank_genes_groups']['names'][cluster_idx]

    # Get the corresponding log fold changes, p-values, and adjusted p-values
    logfoldchanges = raw.uns['rank_genes_groups']['logfoldchanges'][cluster_idx]
    pvals = raw.uns['rank_genes_groups']['pvals'][cluster_idx]
    pvals_adj = raw.uns['rank_genes_groups']['pvals_adj'][cluster_idx]

    # Make sure this cluster is part of the Leiden clusters you are interested in
    cluster_label = f'{cluster_idx}'  # Convert cluster_idx to string for comparison

    if cluster_label in leiden_clusters:
        # Loop through each gene and its associated values
        for gene, logfc, pval, padj in zip(gene_names, logfoldchanges, pvals, pvals_adj):
            # Append each gene's data to the results list
            all_deg_results.append({
                'gene': gene,
                'logfoldchanges': logfc,
                'pvals': pval,
                'pvals_adj': padj,
                'cluster': cluster_label  # Assign the cluster label
            })

# Convert the list of dictionaries into a DataFrame
final_deg_results = pd.DataFrame(all_deg_results)

# Convert the 'cluster' column to numeric for correct sorting
final_deg_results['cluster'] = pd.to_numeric(final_deg_results['cluster'])

# Sort the DataFrame by 'cluster' and 'logfoldchanges' within each cluster
final_deg_results_sorted = final_deg_results.sort_values(by=['cluster', 'logfoldchanges'], ascending=[True, False])

# Optionally, save the results to a CSV file
final_deg_results_sorted.to_csv('/content/drive/MyDrive/20.440 Project/deg_raw.csv', index=False)

# Show the first few rows of the sorted DataFrame
print(final_deg_results_sorted.head())
'''

# mmake it so that i only need to copy/paste one cell to capture all the DEGs to paste into enrichr

# Load your DEGs
df = pd.read_csv('/content/drive/MyDrive/20.440 Project/deg_integrated.csv')

# Create a dictionary to hold the multi-line gene strings per cluster
cluster_gene_text = {}

# Loop over each cluster
for cluster in sorted(df['cluster'].unique(), key=lambda x: int(x)):
    # Get the genes for this cluster
    genes = df[df['cluster'] == cluster]['gene'].dropna().astype(str).tolist()

    # Join them with newline characters so they're pasted as multi-line text
    gene_string = '\n'.join(genes)

    # Save in dict using cluster label as key
    cluster_gene_text[f'cluster_{cluster}'] = [gene_string]  # Note: as list to make it 1 row

# Convert to DataFrame (each cell will contain a multi-line string)
gene_multiline_df = pd.DataFrame(cluster_gene_text)

# Save to CSV
gene_multiline_df.to_csv('/content/drive/MyDrive/20.440 Project/multilineDEGs.csv', index=False)

"""FIX THIS WITH CORRECT CLUSTER CELL TYPES
Copy/Pasting the top DEGs for each cluster into https://maayanlab.cloud/Enrichr/ using Cell Marker 2024 library resulted in the following cell type identifications
- cluster 0: colorectal adenocarcinoma
- cluster 1: smooth muscle
- cluster 2: cingulate cortex
- cluster 3: fetal thyroid
- cluster 4: adipocyte
- cluster 5: smooth muscle
- cluster 6: prostate (followed by placenta)
- cluster 7: bronchial epithelial cells
- cluster 8: cardiac myocyte

###Visualizing Clusters
"""

#Label Clusters w/ cell type or pathway
# Note, some of the labels are the 2nd best if the 1st best did not make sense (ex: prostate)

# cluster cell type label
cell_types_vis = { #for umap visualization and correspondence with cluster numbers
    '0': '0: Smooth Muscle',
    '1': '1: Placenta',
    '2': '2: Placenta',
    '3': '3: Smooth Muscle',
    '4': '4: Smooth Muscle',
    '5': '5: Smooth Muscle',
    '6': '6: Uterus',
    '7': '7: Uterus',
    '8': '8: Uterus',
    '9': '9: Uterus',
    '10': '10: Smooth Muscle',
    '11': '11: 721 B Lymphoblasts',
    '12': '12: Smooth Muscle',
    '13': '13: Unknown'
}

cell_types_bar = { #for stacked bar chart
    '0': 'Smooth Muscle',
    '1': 'Placenta',
    '2': 'Placenta',
    '3': 'Smooth Muscle',
    '4': 'Smooth Muscle',
    '5': 'Smooth Muscle',
    '6': 'Uterus',
    '7': 'Uterus',
    '8': 'Uterus',
    '9': 'Uterus',
    '10': 'Smooth Muscle',
    '11': '721 B Lymphoblasts',
    '12': 'Smooth Muscle',
    '13': 'Unknown'
}

pathways = {
    '0': '0: Phagosome',
    '1': '1: Proteoglycans in Cancer',
    '2': '2: Viral Myocarditis',
    '3': '3: Epsteinn Barr Virus Infection',
    '4': '4: Fluid Shear Stress and Atherosclerosis',
    '5': '5: Phagosome',
    '6': '6: Focal Adhesion',
    '7': '7: Oxytocin Signaling Pathway',
    '8': '8: Ribosome',
    '9': '9: Retrograde endocannabinoid signaling',
    '10': '10: Regulation of Actin cytoskeleton',
    '11': '11: Ribosome',
    '12': '12: Ribosome',
    '13': '13: Ribosome',
    '14': '14: Ribosome',
    '15': '15: Focal Adhesion'
}

# Visualize Cell types
# Map the cluster numbers to the custom names in the 'leiden' column
integrated.obs['cell_types_vis'] = integrated.obs['leiden'].astype(str).map(cell_types_vis)
integrated.obs['cell_types_bar'] = integrated.obs['leiden'].astype(str).map(cell_types_bar)

# Plot UMAP with custom labels
sc.pl.umap(integrated, color='cell_types_vis', show=False)

# Overlay cluster numbers as annotations
for i in range(len(cell_types_vis)):
    cluster_cells = integrated[integrated.obs['leiden'] == str(i)]

    # Get UMAP coordinates for the cluster cells
    x = cluster_cells.obsm['X_umap'][:, 0]
    y = cluster_cells.obsm['X_umap'][:, 1]


    # Display cluster number on the plot
    plt.text(x.mean(), y.mean(), f'{i}', color='black', fontsize=12, ha='center', va='center')

plt.show()

#save cell type as csv for use in parafac analysis stuff
print(integrated.obs['cell_types_bar'])
print(type(integrated.obs['cell_types_bar']))
integrated.obs['cell_types_bar'].to_csv(data_path + '/cell_annot_with_barcode.csv', index = True)

# Visualize Pathways

# Map the cluster numbers to the custom names in the 'leiden' column
integrated.obs['pathways'] = integrated.obs['leiden'].astype(str).map(pathways)

# Plot UMAP with custom labels
sc.pl.umap(integrated, color='pathways', show=False)


# Overlay cluster numbers as annotations
for i in range(len(cell_types_vis)):
    cluster_cells = integrated[integrated.obs['leiden'] == str(i)]

    # Get UMAP coordinates for the cluster cells
    x = cluster_cells.obsm['X_umap'][:, 0]
    y = cluster_cells.obsm['X_umap'][:, 1]


    # Display cluster number on the plot
    plt.text(x.mean(), y.mean(), f'{i}', color='black', fontsize=12, ha='center', va='center')

plt.show()

"""### Stacked bar chart of each sample's cell type composition"""

# Group and count cells per sample and cell type
cell_counts = integrated.obs.groupby(['sample', 'cell_types_bar']).size().unstack(fill_value=0)
print(integrated.obs['cell_types_bar'].value_counts())
cell_props = cell_counts.div(cell_counts.sum(axis=1), axis=0) #convert to proportions
cell_props

#Plot horizontal stacked bar chart

#Extract sample-to-condition mapping from obs (via mode or set)
sample_conditions = (
    integrated.obs.groupby('sample')['disease_status']
    .agg(lambda x: x.mode()[0] if len(x.mode()) > 0 else x.iloc[0])  # handles ties or single values
)

#Sort sample index by condition (e.g., PCOS on top half of bar chart, then healthy on bottom half).
sorted_index = sorted(
    sample_conditions.index,
    key=lambda sample: (sample_conditions[sample], sample)
)


# Reorder cell_props
cell_props = cell_props.loc[sorted_index]


# Define a color palette
cell_type_labels = cell_props.columns
colors = plt.get_cmap('tab10').colors[:len(cell_type_labels)]  # or custom colors

# Plot
fig, ax = plt.subplots(figsize=(10, 8))
bottom = pd.Series([0]*cell_props.shape[0], index=cell_props.index)

for i, cell_type in enumerate(cell_type_labels):
    ax.barh(cell_props.index, cell_props[cell_type], left=bottom, color=colors[i], label=cell_type)
    bottom += cell_props[cell_type]

ax.set_xlabel('Proportion')
ax.set_ylabel('Sample')
ax.set_title('Cell Type Composition per Sample')
ax.legend(title='Cell Type', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

"""###Annotations Attempt with decouple and panglaodb + manual and panglaodb"""

import decoupler as dc
# Query Omnipath and get PanglaoDB
# Omnipath is one of the largest available databases of curated prior knowledge.
# Among its resources, there is PanglaoDB, a database of cell type markers

markers = dc.get_resource(
    name='PanglaoDB',
    organism='human',
    license='academic'
)
markers

# Filter by canonical_marker and human
markers = markers[markers['human'].astype(bool) & markers['canonical_marker'].astype(bool) & (markers['human_sensitivity'].astype(float) > 0.5)]

# Remove duplicated entries
markers = markers[~markers.duplicated(['cell_type', 'genesymbol'])]
markers

# load the markers into a dictionary of form
# {
#    Cell type 1: ['gene marker A', 'gene marker B', etc]
#    Cell type 2: ['gene marker C', 'gene marker D', etc]
#
#}
markers_dict = {}
print(type(markers))
for index, row in markers.iterrows():
  if row['cell_type'] in markers_dict:
    markers_dict[row['cell_type']].append(row['genesymbol'])
  else:
    markers_dict[row['cell_type']] = [row['genesymbol']]

print(len(markers_dict.keys()))

# Subset to only the markers that were detected in our data. We will loop through all cell types
# and keep only the genes that we find in our adata object as markers for that cell type.
# This will prevent errors once we start plotting.

marker_genes_in_data = {}
for ct, markers in markers_dict.items():
    markers_found = []
    for marker in markers:
        if marker in integrated.var.index:
            markers_found.append(marker)
    marker_genes_in_data[ct] = markers_found

!pip  install scikit-misc

# store our raw counts in .layers['counts'], so that we will still have access to them
# later if needed. We then set our adata.X to the scran-normalized, log-transformed counts.


integrated_small.layers["counts"] = integrated_small.X
# Perform normalization using scran
sc.pp.normalize_total(integrated_small, target_sum=1e4)  # Normalize to total sum per cell, now stored in integrated_small.X


#. set our adata.var.highly_variable to the highly deviant genes.
 # Scanpy uses this var column in downstream calculations, such as the PCA below
# Perform the computation of highly variable genes
# Compute highly variable genes using scanpy's definition


# Now run the highly variable genes function
#sc.pp.highly_variable_genes(integrated_small, flavor = 'seurat', n_top_genes = 30)




# Optionally, filter the dataset to keep only the highly variable genes
#integrated_hv = integrated_small[:, integrated_small.var['highly_variable']].copy()

# perform PCA
sc.tl.pca(integrated_small, n_comps=50)

sc.pp.neighbors(integrated_small)
sc.tl.umap(integrated_small)

B_plasma_cts = [
    "Naive CD20+ B",
    "B1 B",
    "Transitional B",
    "Plasma cells",
    "Plasmablast",
]

B_plasma_markers = {
    ct: [m for m in ct_markers if m in integrated_small.var.index]
    for ct, ct_markers in markers_dict.items()
    if ct in B_plasma_cts
}

print(B_plasma_markers)
sc.pl.dotplot(
    integrated_small,
    groupby="leiden",
    var_names=B_plasma_markers,
    standard_scale="var",  # standard scale: normalize each gene to range from 0 to 1
)

'''
# Enrichment with Overrepresentation Analysis

from scipy.sparse import csr_matrix

# Convert the matrix to a sparse format to minimize RAM usage (otherwise, runtime will crash)
#integrated_sparse = csr_matrix(integrated)

# Filter edges based on a threshold (e.g., keep only edges with weight > 0.1)
#markers_filtered = markers[markers['weight'] > 0.1]

dc.run_ora(
    mat=integrated,
    net=markers,
    source='cell_type',
    target='genesymbol',
    min_n=3,
    verbose=True,
    use_raw=False
)

# The obtained scores (-log10(p-value))(ora_estimate) and p-values (ora_pvals) are stored in the .obsm key:
integrated.obsm['ora_estimate']
'''

"""###Attempt with CellTypist"""

!pip install celltypist

import urllib.request
from pathlib import Path

import celltypist
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import scanpy as sc
#import scarches as sca
import seaborn as sns
from celltypist import models
from scipy.sparse import csr_matrix

adata_celltypist = integrated_small.copy()  # make a copy of our adata

adata_celltypist.X = integrated_small.X  # set adata.X to raw counts
sc.pp.normalize_total(
    adata_celltypist, target_sum=10**4
)  # normalize to 10,000 counts per cell (required for celltypist)
sc.pp.log1p(adata_celltypist)  # log-transform
# make .X dense instead of sparse, for compatibility with celltypist:
adata_celltypist.X = adata_celltypist.X


models.download_models(
    force_update=True, model=["Immune_All_Low.pkl", "Immune_All_High.pkl"]
)

#model_low = models.Model.load(model="Immune_All_Low.pkl")
model_high = models.Model.load(model="Immune_All_High.pkl")

model_high.cell_types

models.download_models(
    force_update=True, model=["Immune_All_Low.pkl", "Immune_All_High.pkl"]
)

#model_low = models.Model.load(model="Immune_All_Low.pkl")
model_high = models.Model.load(model="Immune_All_High.pkl")

predictions_high = celltypist.annotate(
    adata_celltypist, model=model_high, majority_voting=False
)

predictions_high_adata = predictions_high.to_adata()

# Ensure that the indices match
predictions_high_adata.obs = predictions_high_adata.obs.reindex(integrated_small.obs.index)

# Now assign the values
integrated_small.obs["celltypist_cell_label_coarse"] = predictions_high_adata.obs["celltypist_cell_label_coarse"]


integrated_small.obs["celltypist_conf_score_coarse"] = predictions_high_adata.obs["celltypist_conf_score_coarse"]

sc.pl.umap(
    integrated_small,
    color=["celltypist_cell_label_coarse", "celltypist_conf_score_coarse"],
    frameon=False,
    sort_order=False,
    wspace=1,
)

# One way of getting a feeling for the quality of these annotations is by looking
# if the observed cell type similarities correspond to our expectations:
sc.pl.dendrogram(integrated_small, groupby="celltypist_cell_label_coarse")