# -*- coding: utf-8 -*-
"""GSEA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CCxv1WDkEML2K9PoUZFgHVgQoo6pPbMV
"""

!pip install gseapy

import pandas as pd
from gseapy.plot import gseaplot
import gseapy as gp
import numpy as np

!pip install scanpy
import scanpy as sc

from google.colab import drive
drive.mount('/content/drive')

"""##DGE Analysis b/w conditions"""

data_path = '/content/drive/MyDrive/20.440 Project/data'
deg_path = '/content/drive/MyDrive/20.440 Project/DEGs'
figures_path = '/content/drive/MyDrive/20.440 Project/Figures'

#load data
integrated = sc.read_h5ad(data_path + '/integrated_2025-04-09.h5ad')
integrated

integrated.obs['treatment'][0] #to see what the forskolin treatment text is (copy/paste)

integrated_forsk = integrated[integrated.obs['treatment'] == 'forskolin 20uM 24hr', :] #filter out forskolin samples
integrated_forsk

#perform DGE between healthy and diseased

sc.tl.rank_genes_groups(integrated_forsk, groupby='disease_status', method='wilcoxon', reference='HC',
                        min_in_group_fraction=0.01,  # match min.pct (from paper)
                        logfc_threshold=0.01)         # match logfc.threshold (from paper)
df_forsk = sc.get.rank_genes_groups_df(integrated_forsk, group = 'PCOS')

sc.tl.rank_genes_groups(integrated, groupby='disease_status', method='wilcoxon', reference='HC',
                        min_in_group_fraction=0.01,  # match min.pct (from paper)
                        logfc_threshold=0.01)         # match logfc.threshold (from paper)
df_all = sc.get.rank_genes_groups_df(integrated, group = 'PCOS')

df_forsk

# Apply a small offset to prevent taking log of zero
epsilon = 1e-10  # small value to prevent log(0)

df_forsk['Rank'] = -np.log10(df_forsk.pvals_adj + epsilon)*df_forsk.logfoldchanges
#df['Rank'] = df.logfoldchanges #paper only ranked by logfc, but when i did this, none of the FDRs were signifcant (all were close to 1)
df_forsk = df_forsk.sort_values('Rank', ascending = False).reset_index(drop = True)
df_forsk

df_all['Rank'] = -np.log10(df_all.pvals_adj + epsilon)*df_all.logfoldchanges
df_all = df_all.sort_values('Rank', ascending = False).reset_index(drop = True)
df_all

ranking_forsk = df_forsk[['names', 'Rank']] #names is the gene column
ranking_forsk

ranking_all = df_all[['names', 'Rank']] #names is the gene column
ranking_all

"""##Stuff that didn't work"""

'''
# Get the results for the group you're interested in
group = 'PCOS'
# Pull logFCs and p-values for the "diseased" group
logfc = integrated.uns['rank_genes_groups']['logfoldchanges'][group]
pvals_adj = integrated.uns['rank_genes_groups']['pvals_adj'][group]
genes = integrated.uns['rank_genes_groups']['names'][group]

ranked_genes_df = pd.DataFrame({
    'gene': genes,
    'logFC': logfc,
    'pvals_adj': pvals_adj
})

# Sort by logFC (or any other metric you want to rank by)
ranked_genes_df = ranked_genes_df.sort_values(by='logFC', ascending=False)

# Now you have your ranked gene list
ranked_genes_df.head()  # Top genes sorted by logFC
'''

'''
gp.get_library_names() #this line doesnt work
#original paper looked at steroidgenesis and cholesterol
#maybe do Hallmark Inflammatory Response, KEGG Insulin Signaling Pathway, KEGG Steroid Biosynthesis,
#GO Term: Ovarian Follicle Development, KEGG Adipogenesis Pathway, Reactome Cytokine Signaling
'''

"""##Perform GSEA"""

##Perform GSEA

#Load and Filter a Local GMT File

def parse_gmt(file_path):
    gene_sets = {}
    with open(file_path, 'r') as f:
        for line in f:
            parts = line.strip().split('\t')
            gene_set_name = parts[0]
            description = parts[1]
            genes = parts[2:]
            gene_sets[gene_set_name] = genes
    return gene_sets

# Path to the full C2 GMT file you downloaded
c2_gmt_file = data_path + '/c2.all.v2024.1.Hs.symbols.gmt'

# Load the gene sets
all_gene_sets = parse_gmt(c2_gmt_file)

# Filter gene sets with keywords like 'steroid', 'cholesterol'
keywords = ['steroid', 'cholesterol', 'lipid', 'inflamm', 'insulin', 'ovar', 'androgen']
filtered_gene_sets = {name: genes for name, genes in all_gene_sets.items()
                      if any(k in name.lower() for k in keywords)}

print(f"Found {len(filtered_gene_sets)} matching gene sets:")
'''
for name in filtered_gene_sets:
    print(name)
'''

"""### Forskolin-filtered GSEA"""

# Run preranked GSEA
pre_res_forsk = gp.prerank(
    rnk=ranking_forsk,
    gene_sets=filtered_gene_sets,       # your custom gene set file
    outdir= figures_path + '/GSEA/forskolin',                  # output folder
    min_size=5,
    max_size=500,
    permutation_num=1000,                     # increase for publication-quality results
    seed=6,
    threads=4,
    verbose=True
)

pre_res_all = gp.prerank(
    rnk=ranking_all,
    gene_sets=filtered_gene_sets,       # your custom gene set file
    outdir= figures_path + '/GSEA/no_filter',                  # output folder
    min_size=5,
    max_size=500,
    permutation_num=1000,                     # increase for publication-quality results
    seed=6,
    threads=4,
    verbose=True
)


# View results
print(pre_res_forsk.res2d)

'''
pre_res.res2d['bonferroni_pval'] = res2d['NOM p-val'] * len(res2d)
pre_res.res2d['bonferroni_pval'] = res2d['bonferroni_pval'].clip(upper=1.0)
sig_sets = pre_res.res2d[pre_res.res2d['bonferroni_pval'] < 0.05]
print(sig_sets)
'''

print(pre_res_forsk.res2d.columns)

print(pre_res_forsk.res2d.head)
# Load GSEA results
res_df_forsk = pre_res_forsk.res2d.copy()  # GSEApy returns results as a pandas DataFrame

# Filter for significant pathways
# You can adjust the threshold as needed (e.g., FDR < 0.05)
sig_res_forsk = res_df_forsk[res_df_forsk['FDR q-val'] < 0.05].copy()
print(sig_res_forsk.head)

import seaborn as sns
import matplotlib.pyplot as plt


# Create a dictionary to store the total number of genes for each pathway
pathway_total_genes = {pathway: len(genes) for pathway, genes in filtered_gene_sets.items()}

# Create a function to calculate GeneRatio
def calculate_gene_ratio(row):
    pathway = row['Term']
    num_enriched_genes = len(row['Lead_genes'].split(';'))  # assuming Lead_genes is a comma-separated string
    total_genes = pathway_total_genes.get(pathway, 0)  # get total genes for the pathway
    return num_enriched_genes / total_genes if total_genes > 0 else 0

# Load GSEA results
res_df_forsk = pre_res_forsk.res2d.copy()  # GSEApy returns results as a pandas DataFrame
res_df_all = pre_res_all.res2d.copy()  # GSEApy returns results as a pandas DataFrame

# Filter for significant pathways
# You can adjust the threshold as needed (e.g., FDR < 0.05)
sig_res = res_df_forsk[res_df_forsk['FDR q-val'] < 0.1].copy()


# Ensure FWER p-val is numeric (this coerces invalid entries to NaN)
sig_res['FDR q-val'] = pd.to_numeric(sig_res['FDR q-val'], errors='coerce')

# Drop rows where FWER p-val is missing or zero (log10(0) is undefined)
sig_res = sig_res[sig_res['FDR q-val'] > 0].copy()

# Create a column for -log10(pval) for dot size
sig_res['log_pval'] = -np.log10(sig_res['FDR q-val'])


# Apply the gene ratio function to each row in the DataFrame to calculate GeneRatio
sig_res['Gene Ratio'] = sig_res.apply(calculate_gene_ratio, axis=1)


# Plot using seaborn
plt.figure(figsize=(8, max(6, 0.3 * len(sig_res))))  # dynamic height based on number of pathways
sns.scatterplot(
    data=sig_res,
    #x='log_pval',
    x = 'Gene Ratio',
    y='Term',  # y-axis is pathway names
    size='log_pval',
    hue='NES',
    palette='coolwarm',
    sizes=(50, 300),
    edgecolor='black',
    legend='brief'
)

plt.xlabel('Gene Ratio')
plt.ylabel('Pathway')
plt.title('GSEA Dotplot of Significant Pathways: non-Parafac')
plt.tight_layout()
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

"""### PARAFAC gsea, component 9 (naive parafac weights)"""

gsea9 = pd.read_csv(data_path + '/gsea_9_FDR_0.05.csv')


# Plot using seaborn
plt.figure(figsize=(8, max(6, 0.3 * len(sig_res))))  # dynamic height based on number of pathways
sns.scatterplot(
    data=gsea9,
    #x='log_pval',
    x = 1,
    y='Term',  # y-axis is pathway names
    size='FDR q-val',
    hue='NES',
    palette='coolwarm',
    sizes=(50, 300),
    edgecolor='black',
    legend='brief'
)

plt.xlabel('Gene Ratio')
plt.ylabel('Pathway')
plt.title('GSEA Dotplot of Significant Pathways: Parafac')
plt.tight_layout()
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

"""### PARAFAC gsea, component 16 (deemed important by linear regression)
(component 26 is b cell cluster)
"""

gsea16 = pd.read_csv(data_path + '/gsea_16_all.csv')


# Plot using seaborn
#plt.figure(figsize=(8, max(6, 0.3 * len(sig_res))))  # dynamic height based on number of pathways
plt.figure(figsize=(8,15))
sns.scatterplot(
    data=gsea16,
    #x='log_pval',
    x = 1,
    y='Term',  # y-axis is pathway names
    size='FDR q-val',
    hue='NES',
    palette='coolwarm',
    sizes=(50, 300),
    edgecolor='black',
    legend='brief'
)

plt.xlabel('Gene Ratio')
plt.ylabel('Pathway')
plt.title('GSEA Dotplot of Significant Pathways: Parafac')
#plt.tight_layout()
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

"""### Parafac b cells"""

def wrap_text(text, width=40):
  import textwrap
  return '\n'.join(textwrap.wrap(text, width))

from mpl_toolkits.axes_grid1.inset_locator import inset_axes

gsea26 = pd.read_csv(data_path + '/gsea_26_all.csv')

gsea26 = gsea26.sort_values(by='Gene %')

# Filter for significant pathways
# You can adjust the threshold as needed (e.g., FDR < 0.05)
gsea26 = gsea26[gsea26['FDR q-val'] < 0.1].copy()
gsea26['Gene Ratio'] = gsea26['Gene %'].str.strip('%').astype(float) / 100
gsea26['Term_wrapped'] = gsea26['Term'].apply(lambda x: wrap_text(x, width=32)) #wrap text of pathway so it's not taking up too much width in figure

# Add a new column to reverse q-values (so big dots are small q values)
gsea26['_inv_qval'] = 1 / gsea26['FDR q-val']

# Plot using seaborn
#plt.figure(figsize=(8, max(6, 0.3 * len(sig_res))))  # dynamic height based on number of pathways
plt.figure(figsize=(4,6))
scatter = sns.scatterplot(
    data=gsea26,
    #x='log_pval',
    x = 'Gene Ratio',
    y='Term_wrapped',  # y-axis is pathway names
    size='_inv_qval',
    hue='NES',
    palette='coolwarm',
    sizes=(50, 300),
    edgecolor='black',
    legend='brief'
)

plt.ylabel('Pathway', fontsize=12)
# Set y-axis tick labels with a smaller font size
plt.yticks(fontsize=7)  # Decrease font size for y-axis terms (tick labels)

plt.title('Enriched Pathways in B cells (Parafac)')


# ----- CLEAN UP LEGEND -----
'''
# Seaborn adds size and hue legend by default, so we'll clean it up
handles, labels = scatter.get_legend_handles_labels()

# Remove hue-related (color) legend entries
new_handles = [handle for handle, label in zip(handles, labels) if label != 'NES']
new_labels = [label for label in labels if label != 'NES']

# Recreate the legend with only the size-related entries (FDR q-val)
scatter.legend(
    handles=new_handles,
    labels=new_labels,
    title="FDR q-val (size)",
    loc='upper right',
    borderaxespad=0.5,
    frameon=True
)
'''

# ----- LEGEND CODE -----

# Get unique sorted FDR values from your data
unique_fdr = sorted(gsea26['FDR q-val'].unique())


# Use min, median-like mid, and max values
min_fdr = min(unique_fdr)
max_fdr = max(unique_fdr)
mid_fdr = (min_fdr + max_fdr) / 2  # simple mid-point


# Round for legend labels
legend_vals = [round(v, 4) for v in [min_fdr, mid_fdr, max_fdr]]
legend_labels = [f"{v:.3f}" for v in legend_vals]



# Convert q-values to inverse for size mapping
legend_inv_qvals = [1 / v for v in legend_vals]
legend_sizes = np.interp(legend_inv_qvals, [1 / max_fdr, 1 / min_fdr], [50, 300])


# Map FDR values to dot sizes (matching your actual dot size range)
#legend_sizes = np.interp(legend_vals, [min_fdr, max_fdr], [50, 300])

# Create dummy handles (black dots of corresponding size)
legend_handles = [
    plt.scatter([], [], s=size, color='black', edgecolor='black')
    for size in legend_sizes
]



#re add legend
scatter.legend(
    handles=legend_handles,
    labels=legend_labels,
    title="FDR q-val",
    bbox_to_anchor=(1.3, 1),
    loc='upper right',
    borderaxespad=0.5,
    labelspacing=1.5,  # Increase vertical space between dots
    frameon=False,  # Remove the box around the legend
)

# ----- ADD VERTICAL COLORBAR -----
# Create mappable for colorbar based on NES
norm = plt.Normalize(gsea26['NES'].min(), gsea26['NES'].max())
sm = plt.cm.ScalarMappable(cmap='coolwarm', norm=norm)
sm.set_array([])


# Create an inset axes for the colorbar inside the plot near the legend
cax = inset_axes(
    scatter.axes,
    width="3%",      # Thin vertical colorbar
    height="25%",    # Height of the colorbar
    loc='upper right',
    bbox_to_anchor=(-0.09, -0.35, 1.18, 1),  # Adjust positioning
    bbox_transform=scatter.axes.transAxes,
    borderpad=0
)



cbar = plt.colorbar(sm, cax=cax, orientation='vertical')

# Adjust the position using the bbox (bounding box) approach
# Manually move the colorbar label using `ax.annotate()`
cbar.ax.annotate(
    "NES",  # Label text
    xy=(0.5, 1.05),  # Position relative to the colorbar (centered horizontally, slightly above)
    xycoords='axes fraction',  # Use fraction of axes for coordinates
    ha='center',  # Horizontal alignment (centered)
    va='bottom',  # Vertical alignment (position it above the colorbar)
    rotation=0,  #0 degreee rotation to display upright properly
    fontsize=9,  # Font size of the label
    color='black',  # Color of the text (adjust as needed)
)


cbar.ax.tick_params(labelsize=8)

#plt.tight_layout()
#plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

for term in gsea26['Term']:
  print(term)

"""####legend function"""

#attempt at function
def add_legend(gsea, FDR_loc, colorbar_loc):
  '''
  gsea: csv with gsea result
  FDR_loc: (x,y) coordinates of desired location of FDR legend
  colorbar_loc: (x,y) coordinates of desired location of FDR legend
  '''
  # ----- LEGEND CODE -----

  # Get unique sorted FDR values from your data
  unique_fdr = sorted(gsea['FDR q-val'].unique())


  # Use min, median-like mid, and max values
  min_fdr = min(unique_fdr)
  max_fdr = max(unique_fdr)
  mid_fdr = (min_fdr + max_fdr) / 2  # simple mid-point

  '''
  # Round for legend labels
  legend_vals = [round(v, 4) for v in [min_fdr, mid_fdr, max_fdr]]
  legend_labels = [f"{v:.3f}" for v in legend_vals]


  # Convert q-values to inverse for size mapping
  epsilon = 1e-10  # small value to prevent division by (0)
  legend_inv_qvals = [1 / (v+epsilon) for v in legend_vals]
  legend_sizes = np.interp(legend_inv_qvals, [1 / (max_fdr+epsilon), 1 / (min_fdr+epsilon)], [50, 300])
  '''
  '''
  legend_vals = [0.0, 0.05, 0.1]
  legend_labels = [f"{v:.3f}" for v in legend_vals]
  legend_inv_qvals = [1 / (v+epsilon) for v in legend_vals]
  legend_sizes = np.interp(
      legend_inv_qvals,
      [gsea['_inv_qval'].min(), gsea['_inv_qval'].max()],
      [50, 300]
  )
  '''
  # Apply log2 instead of log10 for more spread
  legend_vals = [round(v, 4) for v in [min_fdr, mid_fdr, max_fdr]]
  legend_labels = [f"{v:.3f}" for v in legend_vals]
  legend_log_qvals = [-np.log2(v + epsilon) for v in legend_vals]

  legend_sizes = np.interp(
      legend_log_qvals,
      [-np.log2(max_fdr + epsilon), -np.log2(min_fdr + epsilon)],
      [50, 300]
  )




  # Create dummy handles (black dots of corresponding size)
  legend_handles = [
      plt.scatter([], [], s=size, color='black', edgecolor='black')
      for size in legend_sizes
  ]



  #re add legend
  leg = scatter.legend(
      handles=legend_handles,
      labels=legend_labels,
      title="FDR q-val",
      bbox_to_anchor=FDR_loc,
      loc='upper right',
      borderaxespad=0.5,
      labelspacing=1.5,  # Increase vertical space between dots
      frameon=False,  # Remove the box around the legend
  )

  # ----- ADD VERTICAL COLORBAR -----
  # Create mappable for colorbar based on NES
  norm = plt.Normalize(gsea['NES'].min(), gsea['NES'].max())
  sm = plt.cm.ScalarMappable(cmap='coolwarm', norm=norm)
  sm.set_array([])


  # Create an inset axes for the colorbar inside the plot near the legend
  cax = inset_axes(
      scatter.axes,
      width="3%",      # Thin vertical colorbar
      height="25%",    # Height of the colorbar
      loc='upper right',
      bbox_to_anchor=colorbar_loc,  # Adjust positioning
      bbox_transform=scatter.axes.transAxes,
      borderpad=0
  )



  cbar = plt.colorbar(sm, cax=cax, orientation='vertical')

  # Adjust the position using the bbox (bounding box) approach
  # Manually move the colorbar label using `ax.annotate()`
  cbar.ax.annotate(
      "NES",  # Label text
      xy=(0.5, 1.05),  # Position relative to the colorbar (centered horizontally, slightly above)
      xycoords='axes fraction',  # Use fraction of axes for coordinates
      ha='center',  # Horizontal alignment (centered)
      va='bottom',  # Vertical alignment (position it above the colorbar)
      rotation=0,  #0 degreee rotation to display upright properly
      fontsize=9,  # Font size of the label
      color='black',  # Color of the text (adjust as needed)
  )


  cbar.ax.tick_params(labelsize=8)

  return (leg, cbar)

'''
#condensed code block of above 2 blocks. using add_legend function
plt.figure(figsize=(4,6))
scatter = sns.scatterplot(
    data=gsea26,
    #x='log_pval',
    x = 'Gene Ratio',
    y='Term_wrapped',  # y-axis is pathway names
    size='FDR q-val',
    hue='NES',
    palette='coolwarm',
    sizes=(50, 300),
    edgecolor='black',
    legend='brief'
)

plt.ylabel('Pathway', fontsize=12)
# Set y-axis tick labels with a smaller font size
plt.yticks(fontsize=7)  # Decrease font size for y-axis terms (tick labels)

plt.title('Enriched Pathways in B cells (Parafac)')

FDR_loc = (1.3,1)
colorbar_loc = (-0.09, -0.35, 1.18, 1)

add_legend(gsea26, FDR_loc, colorbar_loc)
'''

"""###Parafac and non-parafac on same plot"""

from matplotlib.ticker import MultipleLocator
epsilon = 1e-10  # small value to prevent division by (0)

# Filter for significant pathways
# You can adjust the threshold as needed (e.g., FDR < 0.05)
#sig_res = res_df_forsk[res_df_forsk['FDR q-val'] < 0.1].copy() #filtering by forsk
sig_res = res_df_all[res_df_all['FDR q-val'] < 0.1].copy() #no filter

gsea16 = pd.read_csv(data_path + '/gsea_16_all.csv')

gsea16 = gsea16.sort_values(by='FDR q-val').head(7) #top 10 significant ones
gsea16 = gsea16.sort_values(by='Gene %')

gsea16['Gene Ratio'] = gsea16['Gene %'].str.strip('%').astype(float) / 100
sig_res['Gene Ratio'] = sig_res['Gene %'].str.strip('%').astype(float) / 100

gsea16 = gsea16.dropna(subset=['Term', 'NES', 'FDR q-val', 'Gene Ratio'])
sig_res = sig_res.dropna(subset=['Term', 'NES', 'FDR q-val', 'Gene Ratio'])

gsea16['Term_wrapped'] = gsea16['Term'].apply(lambda x: wrap_text(x, width=32)) #wrap text of pathway so it's not taking up too much width in figure
sig_res['Term_wrapped'] = sig_res['Term'].apply(lambda x: wrap_text(x, width=32)) #wrap text of pathway so it's not taking up too much width in figure


# ---- Consistent term order ------
# Combine and create term order by highest Gene Ratio (across both)
merged = pd.concat([
    gsea16[['Term_wrapped', 'Gene Ratio']],
    sig_res[['Term_wrapped', 'Gene Ratio']]
], ignore_index=True)

merged = merged.dropna().sort_values(by='Gene Ratio', ascending=True)
term_order = merged.drop_duplicates(subset='Term_wrapped')['Term_wrapped'].tolist()

# Apply consistent term order
gsea16['Term_wrapped'] = pd.Categorical(gsea16['Term_wrapped'], categories=term_order[::-1], ordered=True)
sig_res['Term_wrapped'] = pd.Categorical(sig_res['Term_wrapped'], categories=term_order[::-1], ordered=True)

print(gsea16.head())

# Add a new column to reverse q-values (so big dots are small q values)
gsea16['_inv_qval'] = 1 / (gsea16['FDR q-val'] +epsilon)
sig_res['_inv_qval'] = 1 / (sig_res['FDR q-val'] + epsilon)
# ---- Plotting ------

# Create subplots
fig, axs = plt.subplots(1, 2, figsize=(5, 6), sharex=True, sharey=True)

# First subplot (Parafac/gsea16)
scatter = sns.scatterplot(
    data=gsea16,
    x='Gene Ratio',
    y='Term_wrapped',
    size='_inv_qval',
    hue='NES',
    palette='coolwarm',
    sizes=(50, 300),
    edgecolor='black',
    legend=False,
    ax=axs[0]
)

axs[0].set_title('Parafac')
axs[0].set_xlabel('Gene Ratio')

# Set ticks every 0.05
axs[0].xaxis.set_major_locator(MultipleLocator(0.05))
axs[1].xaxis.set_major_locator(MultipleLocator(0.05))
from matplotlib.ticker import FuncFormatter

# Format function for two decimal places, no leading 0
formatter = FuncFormatter(lambda x, _: f"{x:.2f}".lstrip("0") if x != 0 else "0")


# Apply to both subplots
axs[0].xaxis.set_major_formatter(formatter)
axs[1].xaxis.set_major_formatter(formatter)


#axs[0].invert_xaxis()  # Optional: to mirror the plots

# Second subplot (non-Parafac/sig_res)
sns.scatterplot(
    data=sig_res,
    x='Gene Ratio',
    y='Term_wrapped',
    size='_inv_qval',
    hue='NES',
    palette='coolwarm',
    sizes=(50, 300),
    edgecolor='black',
    legend=False,
    ax=axs[1]
)
axs[1].set_title('non-Parafac')
axs[1].set_xlabel('Gene Ratio')

# Adjust y-axis label and tick text sizes
axs[0].set_ylabel('Pathway', fontsize=14)
axs[1].set_ylabel('')  # Avoid duplicate y-label
axs[0].tick_params(axis='y', labelsize=7)  # Smaller text for pathway terms

# ---- Adding Legend ------
FDR_loc = (2.9,1)
colorbar_loc = (-0.09, -0.35, 2.7, 1)

# Find common columns
common_cols = gsea16.columns.intersection(sig_res.columns)

# Subset both DataFrames to only common columns
df1_common = gsea16[common_cols]
df2_common = sig_res[common_cols]

# Combine (concatenate) the two DataFrames
combined_df = pd.concat([df1_common, df2_common], ignore_index=True)

add_legend(combined_df, FDR_loc, colorbar_loc)


# Final layout tweaks
plt.tight_layout()
plt.show()

for term in gsea16['Term']:
  print(term)
for term in sig_res['Term']:
  print(term)

gsea16 = gsea16[:10]

# Assign an x-position for each dataset
# Create slight offsets for visual separation
delta = 0.1
gsea16['x'] = 1 - delta
sig_res['x'] = 1 + delta

# Optionally, add a source column for legend differentiation
#gsea16['Source'] = 'Set1'
#sig_res['Source'] = 'Set2'

# Combine
combined = pd.concat([gsea16, sig_res], ignore_index=True)

# Drop rows missing key values (no dot if there's no data)
combined = combined.dropna(subset=['Term', 'NES', 'FDR q-val'])

# Plot
plt.figure(figsize=(8, 10))
sns.scatterplot(
    data=combined,
    x='x',
    y='Term',
    hue='NES',
    size='FDR q-val',
    palette='coolwarm',
    sizes=(50, 300),
    edgecolor='black',
    legend='brief'
)

# Improve x-axis labels
plt.xticks([1, 2], ['Parafac', 'non-Parafac'])
plt.xlabel('Dataset')

plt.tight_layout()
plt.show()

"""### B cells (non-PARAFAC)"""

cell_annot = pd.read_csv(data_path + '/cell_annot.csv')
cell_annot.rename(columns={'Unnamed: 0': 'barcode'}, inplace=True)
cell_annot = cell_annot.set_index("barcode")
shared_cells = cell_annot.loc[cell_annot.index.intersection(integrated.obs_names)]
integrated.obs['cell_annot'] = integrated.obs_names.map(shared_cells['cell_types_bar'])
cell_annot

integrated_bcells = integrated[integrated.obs['cell_annot'] == '721 B Lymphoblasts', :]
print(integrated_bcells.obs.columns)
num_healthy = (integrated_bcells.obs['disease_status'] == 'HC' ).sum()
num_pcos = (integrated_bcells.obs['disease_status'] == 'PCOS' ).sum()
print(num_healthy)
print(num_pcos)
integrated_bcells

#perform DGE between healthy and diseased

sc.tl.rank_genes_groups(integrated_bcells, groupby='disease_status', method='wilcoxon', reference='HC',
                        min_in_group_fraction=0.01,  # match min.pct (from paper)
                        logfc_threshold=0.01)         # match logfc.threshold (from paper)
df_bcells = sc.get.rank_genes_groups_df(integrated_bcells, group = 'PCOS')

df_bcells

# Apply a small offset to prevent taking log of zero
epsilon = 1e-10  # small value to prevent log(0)

df_bcells['Rank'] = -np.log10(df_bcells.pvals_adj + epsilon)*df_bcells.logfoldchanges
#df['Rank'] = df.logfoldchanges #paper only ranked by logfc, but when i did this, none of the FDRs were signifcant (all were close to 1)
d_bcells = df_bcells.sort_values('Rank', ascending = False).reset_index(drop = True)

ranking_bcells = df_bcells[['names', 'Rank']] #names is the gene column
ranking_bcells

# Run preranked GSEA
pre_res = gp.prerank(
    rnk=ranking_bcells,
    gene_sets=filtered_gene_sets,       # your custom gene set file
    outdir= figures_path + '/GSEA/B_cells',                  # output folder
    min_size=5,
    max_size=500,
    permutation_num=1000,                     # increase for publication-quality results
    seed=6,
    threads=4,
    verbose=True
)



# View results
print(pre_res.res2d)

# Load GSEA results
res_df = pre_res.res2d.copy()  # GSEApy returns results as a pandas DataFrame

# Filter for significant pathways
# You can adjust the threshold as needed (e.g., FDR < 0.05)
sig_res = res_df[res_df['FDR q-val'] < 0.45].copy()

# Sort for better plotting (optional)
sig_res = sig_res.sort_values(by='NES', ascending=False)


# Ensure FWER p-val is numeric (this coerces invalid entries to NaN)
sig_res['FDR q-val'] = pd.to_numeric(sig_res['FDR q-val'], errors='coerce')

# Drop rows where FWER p-val is missing or zero (log10(0) is undefined)
sig_res = sig_res[sig_res['FDR q-val'] > 0].copy()

# Create a column for -log10(pval) for dot size
sig_res['log_pval'] = -np.log10(sig_res['FDR q-val'])


# Apply the gene ratio function to each row in the DataFrame to calculate GeneRatio
if len(sig_res) != 0:
  sig_res['GeneRatio'] = sig_res.apply(calculate_gene_ratio, axis=1)


  # Plot using seaborn
  plt.figure(figsize=(8, max(6, 0.3 * len(sig_res))))  # dynamic height based on number of pathways
  sns.scatterplot(
      data=sig_res,
      #x='log_pval',
      x = 'GeneRatio',
      y='Term',  # y-axis is pathway names
      size='log_pval',
      hue='NES',
      palette='coolwarm',
      sizes=(50, 300),
      edgecolor='black',
      legend='brief'
  )

  plt.xlabel('Gene Ratio')
  plt.ylabel('Pathway')
  plt.title('GSEA Dotplot of Significant Pathways: non-Parafac')
  plt.tight_layout()
  plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
  plt.show()
else:
  print("There were no significiantly enriched pathways")
